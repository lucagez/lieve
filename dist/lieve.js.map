{"version":3,"file":"lieve.js","sources":["../src/decor.mjs","../src/lieve.mjs","../src/utils.mjs","../src/plugins.mjs"],"sourcesContent":["function _send({ content, type = 'text/plain', status = 200 }) {\n  this.statusCode = status;\n  this.setHeader('Content-Type', type);\n  this.end(content);\n};\n\nfunction _set(prop, val) {\n  this[prop] = val;\n};\n\nfunction _next(req, res) {\n  this.index += 1;\n  this.queue[this.index](req, res);\n};\n\nconst decor = (req, res) => {\n  req.set = _set;\n  req.next = _next.bind(req);\n  res.send = _send;\n};\n\nexport default decor;\n","import { _body, _cookie } from './plugins';\nimport { list } from './utils';\nimport decor from './decor';\n\n// const pipe = ops => ops.reduce((a, b) => async (ctx) => await b(a(ctx)));\n\nclass Lieve {\n  constructor(routes) {\n    this.routes = routes;\n    this.list = list(routes);\n    this.index = 0;\n\n    this.find = this.find.bind(this);\n    this.router = this.router.bind(this);\n  };\n\n\n  find(url) {\n    const params = [];\n\n    const pieceOrParam = e => this.list.indexOf(e) > -1\n      ? e\n      : (() => {\n        params.push(e);\n        return ':par';\n      })();\n\n    const path = '/' + url\n      .replace(/\\/$/g, '')\n      .split('/').slice(1)\n      .map(pieceOrParam)\n      .join('/');\n\n    return { path, params };\n  };\n\n  router(req, res) {\n    const { url, method } = req;\n    decor(req, res);\n    try {\n      // before/after every request\n      const { before = [], after = [] } = this.routes;\n      const { path, params } = this.find(url);\n\n      const route = this.routes[path] || {};\n      // pre/post route handler\n      const { pre = [], post = [] } = route;\n      const handler = route[method];\n      if (typeof handler !== 'function') throw new Error('undefined endpoint');\n\n      const queue = [...before, ...pre, handler, ...post, ...after];\n      \n      req.set('params', params);\n      req.set('queue', queue);\n      req.set('index', 0);\n\n      queue[0](req, res);\n\n      // boh (:\n      // pipe([...before, ...pre, handler, ...post, ...after])({ req, res });\n    } catch (err) {\n      res.send({\n        type: 'application/json',\n        status: 404,\n        content: JSON.stringify({\n          error: 'Not Found',\n          status: 404,\n        }),\n      });\n    }\n  };\n};\n\nexport {\n  Lieve,\n  _body,\n  _cookie,\n};","const list = (routes) => {\n  const pieces = Object.keys(routes)\n    .map(e => e.split('/').slice(1))\n    .flat()\n    .filter(e => e !== ':par');\n\n  return Array.from(new Set(pieces));\n};\n\nexport { list };\n","function _body(req, type) {\n  return new Promise(resolve => {\n    const chunks = [];\n    req.on('data', chunk => chunks.push(chunk))\n    req.on('end', () => {\n      const body = Buffer.concat(chunks).toString();\n      switch (type) {\n        case 'x-www-form-urlencoded':\n          const parsed = {};\n          body.split('&').map(e => {\n            const [prop, value] = e.split('=');\n            parsed[prop] = value;\n          });\n          resolve(parsed);\n          break;\n        case 'binary':\n          resolve({ file: body });\n          break;\n        default:\n          resolve(body);\n      }\n    });\n  });\n};\n\nfunction _cookie(req) {\n  const { cookie } = req.headers;\n  if (!cookie) return {};\n  const basket = {};\n  cookie.split(';').forEach(e => {\n    const [prop, value] = e.split('=').map(e => e.trim());\n    basket[prop] = value;\n  });\n  return basket;\n}\n\nexport {\n  _body,\n  _cookie,\n};\n"],"names":["_send","ref","statusCode","status","setHeader","type","end","content","_set","prop","val","const","Lieve","constructor","routes","list","pieces","Object","keys","map","e","split","slice","flat","filter","Array","from","Set","index","find","this","bind","router","url","params","replace","indexOf","push","join","req","res","set","next","queue","send","decor","route","handler","method","Error","before","pre","post","after","err","JSON","stringify","Promise","resolve","chunks","on","chunk","body","Buffer","concat","toString","parsed","file","headers","cookie","basket","forEach","trim"],"mappings":"AAAA,SAASA,EAAMC,2CAAkB,4CAAuB,UACjDC,WAAaC,OACbC,UAAU,eAAgBC,QAC1BC,IAAIC,GAGX,SAASC,EAAKC,EAAMC,QACbD,GAAQC,EAQfC,ICTMC,EACJC,SAAYC,QACLA,OAASA,OACTC,cCTKD,OACNE,EAASC,OAAOC,KAAKJ,GACxBK,aAAIC,UAAKA,EAAEC,MAAM,KAAKC,MAAM,KAC5BC,OACAC,gBAAOJ,SAAW,SAANA,WAERK,MAAMC,KAAK,IAAIC,IAAIX,IDGZD,CAAKD,QACZc,MAAQ,OAERC,KAAOC,KAAKD,KAAKE,KAAKD,WACtBE,OAASF,KAAKE,OAAOD,KAAKD,OAIjCD,YAAAA,cAAKI,cACGC,EAAS,SAeR,MANM,IAAMD,EAChBE,QAAQ,OAAQ,IAChBd,MAAM,KAAKC,MAAM,GACjBH,aAVkBC,UAAKU,EAAKf,KAAKqB,QAAQhB,IAAM,EAC9CA,GAEAc,EAAOG,KAAKjB,GACL,UAORkB,KAAK,YAEOJ,IAGjBF,YAAAA,gBAAOO,EAAKC,oCDrBCD,EAAKC,GAClBD,EAAIE,IAAMjC,EACV+B,EAAIG,KAPN,SAAeH,EAAKC,QACbZ,OAAS,OACTe,MAAMb,KAAKF,OAAOW,EAAKC,IAKXT,KAAKQ,GACtBC,EAAII,KAAO5C,ECoBT6C,CAAMN,EAAKC,aAG2BV,KAAKhB,iCAAxB,iCAAY,UACJgB,KAAKD,KAAKI,cAE7Ba,EAAQhB,KAAKhB,gBAAgB,0BAErB,gCAAW,QACnBiC,EAAUD,EAAME,MACC,mBAAZD,EAAwB,MAAM,IAAIE,MAAM,0BAE7CN,EAAYO,SAAWC,GAAKJ,GAASK,EAASC,KAEhDZ,IAAI,SAAUP,KACdO,IAAI,QAASE,KACbF,IAAI,QAAS,KAEX,GAAGF,EAAKC,GAId,MAAOc,KACHV,KAAK,MACD,0BACE,IACRrC,QAASgD,KAAKC,UAAU,OACf,mBACC,wCElElB,SAAejB,EAAKlC,UACX,IAAIoD,iBAAQC,OACXC,EAAS,GACfpB,EAAIqB,GAAG,gBAAQC,UAASF,EAAOtB,KAAKwB,KACpCtB,EAAIqB,GAAG,qBACCE,EAAOC,OAAOC,OAAOL,GAAQM,kBAC3B5D,OACD,4BACG6D,EAAS,GACfJ,EAAKzC,MAAM,KAAKF,aAAIC,SACIA,EAAEC,MAAM,KAC9B6C,eAEFR,EAAQQ,aAEL,SACHR,EAAQ,CAAES,KAAML,kBAGhBJ,EAAQI,yBAMlB,SAAiBvB,SACIA,EAAI6B,mBAClBC,EAAQ,MAAO,OACdC,EAAS,UACfD,EAAOhD,MAAM,KAAKkD,iBAAQnD,SACFA,EAAEC,MAAM,KAAKF,aAAIC,UAAKA,EAAEoD,SAC9CF,eAEKA"}