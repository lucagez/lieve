{"version":3,"file":"lieve.mjs","sources":["../src/_utils.mjs","../src/_use.mjs","../src/_find.mjs","../src/_defaultConfig.mjs","../src/lieve.mjs","../src/_on.mjs","../src/_redirect.mjs","../src/_start.mjs","../src/_next.mjs"],"sourcesContent":["const deSlash = str => str.replace(/\\//g, '');\n\nconst sendNotFound = (res, messageObj) => {\n  const { type, message } = messageObj;\n  res.writeHead(404, {\n    'Content-Type': type,\n  });\n  res.end(message);\n};\n\nconst arrayIsMadeOfFuncs = arr => arr\n  .filter(e => typeof e !== 'function')\n  .length > 0;\n\nexport {\n  deSlash,\n  sendNotFound,\n  arrayIsMadeOfFuncs,\n};\n","\n// Reusing the same function both for middlewares and error middlewares\nfunction use(type) {\n  // Adding the provided function at the end of the registered middleware queue.\n  // => preserve the registration order.\n  return function useScoped(func) {\n    if (typeof func !== 'function') throw new TypeError('Middleware must be of type function');\n    this[type] = [\n      ...this[type],\n      func,\n    ];\n  };\n}\n\nexport default use;\n","// SUPER FASTER\nconst find = (lookup, queryDelimiter) => {\n  const matchQuery = new RegExp(`\\\\${queryDelimiter}(.*)`);\n\n  return (url) => {\n    // Initializing the final path to an empty string\n    let path = '';\n    let query;\n    const params = [];\n\n    // Process url pieces\n    const pieces = url.split('/');\n\n    // If a question mark is found inside the url it means\n    // that the url is carrying query string parameter.\n    // So, we need to destroy them to process against the Set storing all\n    // the available endpoint pieces.\n    if (url.indexOf(queryDelimiter) > -1) {\n      const slast = pieces.length - 1;\n      pieces[slast] = pieces[slast].replace(matchQuery, (match) => {\n        // Deleting delimiter  from query string\n        query = match.substr(1);\n        return '';\n      });\n    }\n\n    // Ugly for-loop but **WAY** faster than a more shiny .map\n    const last = pieces.length;\n    for (let i = 0; i < last; i++) {\n      const piece = pieces[i];\n      // Here is the power of the Set for storing pieces.\n      // .has takes O(1) time, while a search in an array would take O(n).\n\n      // NOTE: it turn out that checking if a Set `has` an item is 10x slower\n      // than checking existence from a regular object.\n      if (typeof lookup[piece] !== 'undefined') path += piece;\n      else {\n        // Everything that is not recognised will be called :par and returned in an array.\n        // This is convenient as the order of insertion will be equal as in the endpoint\n        // definition.\n        // Params can be queried like that:\n        // const [par1, par2] = params;\n        params.push(piece);\n        path += ':par';\n      }\n    }\n\n    return { path, params, query };\n  };\n};\nexport default find;\n","const defaultConfig = {\n  queryDelimiter: '?',\n  notFound: {\n    message: 'Not Found',\n    type: 'text/plain',\n  },\n};\n\nfunction buildDefaultConfig(config) {\n  Object.keys(defaultConfig).forEach((e) => {\n    this[e] = config[e] || defaultConfig[e];\n  });\n}\n\nexport default buildDefaultConfig;\n","import { METHODS } from 'http';\nimport _on from './_on';\nimport _redirect from './_redirect';\nimport _use from './_use';\nimport _start from './_start';\nimport _buildDefaultConfig from './_defaultConfig';\n\nclass Lieve {\n  constructor(config = {}) {\n    this.routes = new Map();\n    this.asRegistered = [];\n    this.middlewares = [];\n    this.errMiddlewares = [];\n    this.lookup = null;\n    this.find = null;\n\n    _buildDefaultConfig.bind(this)(config);\n\n    // Adding all supported methods\n    // => calling router.[method] instead of .on([method])\n    METHODS.forEach((method) => {\n      this[method] = _on(method).bind(this);\n    });\n\n    this.redirect = _redirect.bind(this);\n    this.use = _use('middlewares').bind(this);\n    this.err = _use('errMiddlewares').bind(this);\n    this.start = _start.bind(this);\n  }\n}\n\nexport default Lieve;\n","import { deSlash, arrayIsMadeOfFuncs } from './_utils';\n\nfunction on(method) {\n  return function onScoped(endpoint, middlewares, handler) {\n    // error handling\n    if (typeof handler !== 'function') throw new TypeError('Handler must be a function');\n    if (!Array.isArray(middlewares)) throw new TypeError('Middlewares must be an array');\n    if (middlewares.length > 0 && arrayIsMadeOfFuncs(middlewares)) throw new TypeError('Every middleware should be a function');\n\n    const normalized = deSlash(endpoint);\n    this.asRegistered.push(endpoint);\n\n\n    // `actual` is the object containing every handler specific for every\n    // method belonging to the same endpoint.\n    const actual = this.routes.get(normalized) || {};\n    this.routes.set(normalized, {\n      ...actual,\n      [method]: [\n        // specific to this handler\n        ...middlewares,\n        // handler after all\n        handler,\n      ],\n    });\n  };\n}\n\nexport default on;\n","import { deSlash } from './_utils';\n\nfunction redirect(arg, router) {\n  // case string => route extension\n  const newRoutes = new Map();\n  const {\n    routes, asRegistered, middlewares, errMiddlewares,\n  } = router;\n  const prefix = deSlash(arg);\n\n  // Inheriting old routes and prefixing with new parent router\n  routes.forEach((handler, str) => newRoutes.set(`${prefix}${str}`, handler));\n\n  // Merging new Routes and registered endpoints with the ones that\n  // were previously stored.\n  this.routes = new Map([\n    ...Array.from(this.routes),\n    ...Array.from(newRoutes),\n  ]);\n\n  // new asRegistered => update for new prefix\n  this.asRegistered = [\n    ...this.asRegistered,\n    ...asRegistered.map(path => `${prefix}${path}`),\n  ];\n\n  // Inheriting old middlewares\n  this.middlewares = [\n    ...this.middlewares,\n    ...middlewares,\n  ];\n\n  // Inheriting old errMiddlewares\n  this.errMiddlewares = [\n    ...this.errMiddlewares,\n    ...errMiddlewares,\n  ];\n}\n\nexport default redirect;\n","import _find from './_find';\nimport next from './_next';\nimport { sendNotFound } from './_utils';\n\nfunction start() {\n  // Setting up lookup before initializing.\n  // The lookup is made with all the existing pieces that are\n  // found in the registered endpoints.\n  // e.g. '/shop/products' => 'shop' 'products' => _find will build the url either\n  // with one of the registered pieces or with :par.\n  // NOTE: an empty string '' is added to the lookup object on purpose because, when splitting\n  // a url string, the first item of the resulting array will always be an empty string.\n  // Not including it will result in an unwanted :par added at the beginning\n  // of the resulting string.\n  this.lookup = [\n    ...this.asRegistered\n      .map(route => route.split('/'))\n      .flat(),\n    '',\n  ].reduce((obj, key) => ({ ...obj, [key]: 0 }), {});\n\n  this.find = _find(this.lookup, this.queryDelimiter);\n\n  // Retrieving old queues and adding at the queues the global middlewares.\n  // If avoiding this operation on every new `use` insertion,\n  // when redirecting a path to a new router, every global middleware\n  // defined after the redirection will be ignored.\n  // NOTE: making the queue on every insertion is lightening the work that has to be done\n  // on each incoming request.\n  // => The queue will no longer be created on request. But a global queue for each endpoint\n  // is created beforehand.\n  this.routes.forEach((actual, route) => {\n    const newQueue = {};\n    Object.keys(actual).forEach((method) => {\n      newQueue[method] = [\n        ...this.middlewares,\n        ...actual[method],\n      ];\n    });\n\n    // Finally setting the new updated queue.\n    this.routes.set(route, newQueue);\n  });\n\n  return (req, res) => {\n    const { url, method } = req;\n    const { path, params, query } = this.find(url);\n\n    const endpoint = this.routes.get(path) || {};\n\n    // composing the global middlewares with the middlewares defined\n    // for just one endpoint\n    const queue = endpoint[method];\n\n    if (typeof queue !== 'object') return sendNotFound(res, this.notFound);\n\n    req.params = params;\n    req.query = query;\n\n    // Creating the queue and the generator containing every middleware.\n    // When starting the first function in the queue will be invoked.\n    next(queue, this.errMiddlewares, req, res)();\n  };\n}\n\nexport default start;\n","// This function will invoke\n// in a `connect` like fashion, the next function in the queue\n// passing by reference the req/res objects and the scoped `nextScoped` function.\nconst next = (queue, errQueue, req, res) => {\n  let usedQueue = queue;\n  let current = 0;\n  return function nextScoped(err) {\n    // Defining args as an array => when an error is passed to\n    // next func the array is updated as the error middlewares supports\n    // a different arguments order.\n    // This is necessary to keep Express/Connect compatibility\n    let args = [req, res, nextScoped];\n\n    // pseudocode for err handling\n    // if (err) => TODO: send to error handling middleware\n    // flow: if err\n    // => build err queue from err middlewares\n    // => init counter to 0 again\n    // => set `usedQueue` to errQueue\n    // => continue flow as usual\n    if (err !== undefined) {\n      usedQueue = errQueue;\n      current = 0;\n\n      // swap arg list\n      args = [err, req, res, nextScoped];\n    }\n\n    const nextFunc = usedQueue[current++];\n    if (nextFunc) return nextFunc(...args);\n  };\n};\n\nexport default next;\n"],"names":["const","deSlash","str","replace","use","type","func","TypeError","this","defaultConfig","queryDelimiter","notFound","message","constructor","config","routes","Map","asRegistered","middlewares","errMiddlewares","lookup","find","Object","keys","forEach","e","bind","METHODS","method","endpoint","handler","Array","isArray","length","filter","normalized","push","actual","get","set","_on","redirect","arg","router","newRoutes","prefix","from","map","path","_use","err","start","matchQuery","route","split","flat","reduce","obj","key","RegExp","url","query","params","pieces","indexOf","slast","match","substr","last","i","piece","newQueue","req","res","queue","messageObj","writeHead","end","sendNotFound","errQueue","usedQueue","current","nextScoped","args","undefined","nextFunc","next"],"mappings":"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"}